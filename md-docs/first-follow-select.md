
# first-follow-select

## first集

first集的求法比较简单, 就是对于每一条产生式 `A -> XYZ` 依次判断其右侧的推导式 `XYZ`

1. 首先判断出那些是终结符,那些是非终结符
2. 观察右侧的推导式 `XYZ` 
   
   - 如果第一个字符 `X` 是一个终结符, 那么将 `X` 加入 `A` 的first集, **结束**
   - 如果 `X` 是一个非终结符, 那么将非终结符 `X` 的first集的**所有除ε以外的元素**加入到 `A` 的first集
     - 如果 `X` 中包含ε, 则说明`X`仍可能为空,继续往下判断 `Y`
       - 如果该产生式右侧的最后一个字符 `Z` 并且 `Z` 中仍然包含ε, 则将ε 加入到 `A` 的first集, **结束**
     - 如果 `X` 中不包含ε, **结束**

例 4:

```txt
S -> aS'
S'-> ST | ε
T -> +S' | *S'
```

我们可以求出如下 FIRST 集

| FIRST 集  |       元素        |
| :-------: | :---------------: |
| FIRST(S)  |        {a}        |
| FIRST(S') | {ε,a} |
| FIRST(T)  |      {+,\*}       |

例 5:

```txt
S -> (L)|a
L -> L,S | S
```

先消除左递归,得到

```txt
S -> (L) | a
L -> SL'
L'-> ,SL' | ε
```

然后再计算 FIRST 集

| FIRST 集  |  元素   |
| :-------: | :-----: |
| FIRST(S)  |  {(,a}  |
| FIRST(L)  |  {(,a}  |
| FIRST(L') | {`,`,ε} |

例 7: 例 1 已经消除左递归的式子,略微比之前的复杂一些

```txt
E -> TE'
E' -> +TE'|-TE'|ε
T -> FT'
T' -> *FT'|/FT'|ε
F -> (E) | id
```

| FIRST 集  |   元素   |
| :-------: | :------: |
| FIRST(E)  |  {(,id}  |
| FIRST(E') | {+,-,ε}  |
| FIRST(T)  |  {(,id}  |
| FIRST(T') | {\*,/,ε} |
| FIRST(F)  |  {(,id}  |

如果真的计算 FIRST 集的时候就会发现当我们发现 E 的 FIRST 集元素应该是 T 的 FIRST 集元素,但是现在 T 的 FIRST 集中还没有元素,只有当后面 T 的 FIRST 集更新之后,才能在回过来更新 E 的 FIRST 集.

从代码角度看的话就是一个循环,直到一轮结束之后所有 FIRST 集都没有更新,那么结束循环,否则再次查看有没有需要更新的 FIRST 集

这一点有需要注意, FIRST集虽然只看右侧产生式的首字符,但是还需要注意当这个首字符是非终结符且包含 `ε` 的时候, 还应该继续往下看

## FOLLOW 集

FIRST 集和 FOLLOW 集通常是一起出现一起考,FOLLOW 集的计算和 FIRST 集密不可分,**我们需要先计算所有元素的 FIRST 集之后才能计算 FOLLOW 集**

FOLLOW 集: 可能在某个句型中紧跟在 A 后面的终结符 a 的集合,如果 A 是某个句型的最右符号则把$也加入 FOLLOW 集

对于产生式 `A -> BCDEF`

1. 将 $ 加入到起始元素 S 的follow集中

   这里要注意, $ 只加入到起始元素的follow集中, 表示结尾. 这里的 `A -> BCDF` 只是众多的产生式中的一个, 并不是把 $ 加入到每个产生式左侧的A中!

2. 先观察右侧的 `BCDEF`, 顺序观察遍历
   1. 如果是 `B` 是终结符, 下一个
   2. 如果 `B` 是非终结符
      1. 把 `C` 的first集加入到 `B` 的follow集中, 因为C在B后面,所以B后面肯定可以跟C的开头的字符
      2. 如果 `C` 的first集中包含 ε, 那么接着往下看 `D`, 直到没有 ε. 如果到结尾F了还存在ε, 那么把ε加入到B的first集中, **结束**
   3. 接着看C D E
   4. 如果产生式的结尾 `F` 是一个非终结符, 那么把 `A` 的follow集加入到 `F` 的follow集中

      注意这里一定不要搞反了! 是把 A 的follow加入到 F的follow中

例 5:

```txt
S -> (L) | a
L -> SL'
L' -> ,SL' | ε
```

这里的 FOLLOW 集的求法分为三步:

1. 先观察某一个非终结符后面有没有直接跟了终结符, 比如 L),那么就把 `)` 加入到 FOLLOW(L)
2. 再观察两个非终结符连在一起的, 比如 SL',这种就是 S 后面跟的就应该是 L'的开头,所以把 FIRST(L')加入到 FOLLOW(S)
3. 最后一种就是观察一个推导是不是以非终结符结尾, 比如 `L -> SL'`,那么能跟在 L 后面的一定也能跟在 L'后面,FOLLOW(L)加入到 FOLLOW(L')中.


这里要重点说明一下: `L -> SL'` **是把 FOLLOW(L)加入到 FOLLOW(L')**,**但是不能把 FOLLOW(L')加入到 FOLLOW(L)中**
如果说你后续向 FOLLOW(L)中追加了其他元素,FOLLOW(L')也应该在下一轮中更新

> 当然如果不是写代码而是做题的话就留个心眼记得更新就好了

FOLLOW 集的定义就是找到能跟在某一非终结符后面的所有终结符,正是因为 L 具有一个产生式 `L -> SL'`,所以能跟在 L 的 FOLLOW 集中的元素一定是 FOLLOW(L')中的元素,后续向 FOLLOW(L)中追加的元素也应该补充到 FOLLOW(L')中

这个式子的左侧非终结符是 L,也就是说现在我们考虑的是 L 对其产生式的影响,能跟在 L 后面的一定可以跟在其产生式后面,所以 FOLLOW(L)应该加入到产生式结尾的非终结符的 FOLLOW 集中.

我举一个实际一些的例子来理解一下 FOLLOW 集的作用,假设有如下文法

```txt
A -> 2CB
B -> 1B | ε
C -> 3C4 | ε
```

可以用眼睛看一看,这个式子表示的含义是推导一个类似 `23^n4^n1^m` 的字符串,开头是 2,结尾是一堆 1,中间是数量相同的 3 和 4

先求 FIRST 集

|  FIRST   | ITEM  |
| :------: | :---: |
| FIRST(A) |  {2}  |
| FIRST(B) | {1,ε} |
| FIRST(C) | {3,ε} |

FOLLOW(C)很好求

- C->3C4|ε 可以得到 FOLLOW(C) = {4}
- A->2CB 可以得到 FOLLOW(C) = {4} + FIRST(B)-ε = {4,1}

所以最后 FOLLOW(C) = {$,4,1},表示如果现在的状态是 C,那么后面跟着的不是 1 就是 4

因为 B -> ε,A -> 2CB,所以 FOLLOW(A)加入到 FOLLOW(C),这是合理的,虽然没啥用

但是你不能把 FOLLOW(C)加入到 FOLLOW(A)里,A 就是最开始的推导串,哪里有什么其他非终结符作为 FOLLOW 呢?

**所以 FOLLOW 集的添加是不可逆的**,将 FOLLOW(A)加入到 FOLLOW(C)中


最后一个补充的就是和 FIRST 集的推导中的提示类似,如果某一个推导可能推导出空串,那么就要注意如果它是空的情况

如果 FIRST 集中含有 ε,那么我们不把 ε 加入到 FOLLOW 集.FOLLOW 集都是不含 ε 的,因为就算 ε 可以跟在一个非终结符后面,这也没啥意义.

拉的有点远了我们回到这一题


```txt
S -> (L) | a
L -> SL'
L' -> ,SL' | ε
```

| FIRST 集  |  元素   | FOLLOW 集  |   元素    |
| :-------: | :-----: | :--------: | :-------: |
| FIRST(S)  |  {(,a}  | FOLLOW(S)  | {$,`,`,)} |
| FIRST(L)  |  {(,a}  | FOLLOW(L)  |   {$,)}   |
| FIRST(L') | {`,`,ε} | FOLLOW(L') |   {$,)}   |

例 7: 例 1 已经消除左递归的式子,略微比之前的复杂一些

```txt
E -> TE'
E' -> +TE'|-TE'|ε
T -> FT'
T' -> *FT'|/FT'|ε
F -> (E) | id
```

| FIRST 集  |   元素   | FOLLOW 集  |     元素     |
| :-------: | :------: | :--------: | :----------: |
| FIRST(E)  |  {(,id}  | FOLLOW(E)  |    {$,)}     |
| FIRST(E') | {+,-,ε}  | FOLLOW(E') |    {$,)}     |
| FIRST(T)  |  {(,id}  | FOLLOW(T)  |   {$,+,-}    |
| FIRST(T') | {\*,/,ε} | FOLLOW(T') |   {$,+,-}    |
| FIRST(F)  |  {(,id}  | FOLLOW(F)  | {$,\*,/,+,-} |

> 怕我没说清楚这里再提一句解释一下

- T -> FT'
- T' -> *FT'|/FT'|ε

这两个推导式可以看出来存在 T'->ε 的产生式,所以不止有 FOLLOW(T)加入到 FOLLOW(T'),还有 FOLLOW(T)加入到 FOLLOW(F)

> 这两步都是有的,只不过说如果 FOLLOW 集元素重复会去重,没有明显变化罢了
